import mpmath as mp
import numpy as np
import ROOT
def calculate_error_propagation(x, coeffs, x_error, p):
    """
    Calculate error propagation, compute the error in f based on the formula
    """
    f_error = mp.mpf(0)
    for k in range(1, p + 1):
        f_error += k * coeffs[k] * (x ** (k - 1)) * x_error
    return f_error

def svd_inverse(A):
    """
    Compute the pseudo-inverse of matrix A using SVD
    """
    U, s, Vt = np.linalg.svd(A)
    s_inv = np.array([1 / si if si > 1e-10 else 0 for si in s])
    A_inv = Vt.T @ np.diag(s_inv) @ U.T
    return A_inv

def weighted_least_squares(x_data, y_data, x_errors, y_errors, p, tol=1e-10, max_iter=100, lambda_reg=1e-5):
    # Use high precision with mpmath
    mp.dps = 50  # Set precision to 50 decimal places

    n = len(x_data)
    
    # Convert data to mpmath matrices
    x = mp.matrix(x_data)
    y = mp.matrix(y_data)

    # Construct design matrix F, including bias term and polynomial terms
    F = mp.matrix([[mp.mpf(x_data[i])**j for j in range(p + 1)] for i in range(n)])
    
    # Initial fit with regularization to handle singularity
    P_init = mp.diag([mp.mpf(1) / (mp.mpf(y_errors[i]) ** 2) for i in range(n)])
    regularization = lambda_reg * mp.eye(p + 1)
    Ft_Pinit_F = F.T * P_init * F + regularization

    # Convert to numpy for SVD
    Ft_Pinit_F_np = np.array(Ft_Pinit_F.tolist(), dtype=np.float64)
    F_T_Pinit_np = np.array((F.T * P_init).tolist(), dtype=np.float64)
    y_np = np.array(y.tolist(), dtype=np.float64)

    A_init_np = svd_inverse(Ft_Pinit_F_np) @ F_T_Pinit_np @ y_np
    A_init = [mp.mpf(float(ai)) for ai in A_init_np]
    
    for iteration in range(max_iter):
        # Calculate error propagation
        f_errors = [calculate_error_propagation(mp.mpf(x_data[i]), A_init, mp.mpf(x_errors[i]), p) for i in range(n)]
        
        # Construct total errors
        total_errors = [mp.mpf(y_errors[i] ** 2) + f_errors[i] ** 2 for i in range(n)]
        P = mp.diag([mp.mpf(1) / e for e in total_errors])

        Ft_P_F = F.T * P * F + regularization

        # Convert to numpy for SVD
        Ft_P_F_np = np.array(Ft_P_F.tolist(), dtype=np.float64)
        F_T_P_np = np.array((F.T * P).tolist(), dtype=np.float64)

        # Compute new parameters with SVD inverse
        A_new_np = svd_inverse(Ft_P_F_np) @ F_T_P_np @ y_np
        A_new = [mp.mpf(float(ai)) for ai in A_new_np]

        # Check convergence
        if all(abs(A_new[i] - A_init[i]) < tol for i in range(len(A_new))):
            break

        A_init = A_new

    # Print intermediate variables and results
    print(f"Design matrix F:\n{F}")
    print(f"Initial weight matrix P_init:\n{P_init}")
    print(f"Initial parameters A_init:\n{A_init}")
    print(f"Final weight matrix P:\n{P}")
    print(f"Final parameters A_new:\n{A_new}")

    return A_new

def main():
    # Example data
    T = [516544.63, 516530.31, 516527.08, 516520.94, 516517.33]
    TError = [1, 1, 1, 1, 1]
    MoQ = [2.33054, 2.33041, 2.33038, 2.33033, 2.33030]
    MoQError = [4.44754e-9, 5.07318e-8, 5.50761e-8, 1.13020e-10, 6.86353e-8]
    
    # Create TGraphErrors
    graph = ROOT.TGraphErrors()
    for i in range(len(T)):
        graph.SetPoint(i,T[i],MoQ[i])
        graph.SetPointError(i,TError[i],MoQError[i])
        # Set titles and labels
    graph.SetTitle("Mass Calibration; T; MoQ")
    graph.SetMarkerStyle(21)
    graph.SetMarkerSize(1)
    graph.SetMarkerColor(ROOT.kBlue)

    # Draw the graph
    canvas = ROOT.TCanvas("canvas", "Mass Calibration", 800, 600)
    canvas.Divide(2,2)
    canvas.cd(1)
    graph.Draw("AP")

    # Perform a polynomial fit of degree 2
    fit = ROOT.TF1("fit", "pol2", T[0], T[len(T)-1])
    graph.Fit(fit, "RNQ")

    # Draw the fit result
    fit.Draw("same")


    # Print fitting parameters
    fit_params = [fit.GetParameter(i) for i in range(3)]
    print(f"Fitting parameters: a0 = {fit_params[0]}, a1 = {fit_params[1]}, a2 = {fit_params[2]}")

    # Set the degree of the polynomial
    p = 2

    # Try different regularization parameters
    for lambda_reg in [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1.0]:
        print(f"Trying lambda_reg = {lambda_reg}")
        try:
            # Perform weighted least squares fitting
            beta = weighted_least_squares(T, MoQ, TError, MoQError, p, lambda_reg=lambda_reg)
            # Print the fitting parameters
            print(f"Fitting parameters with lambda_reg = {lambda_reg}: {beta}")
            break
        except ZeroDivisionError as e:
            print(f"Failed with lambda_reg = {lambda_reg}: {e}")
            
    if beta:
        # Create a TF1 object using the beta parameters from weighted least squares
        func = ROOT.TF1("func", f"[0] + [1]*x + [2]*x*x", T[0], T[-1])
        func.SetParameter(0, float(beta[0]))
        func.SetParameter(1, float(beta[1]))
        func.SetParameter(2, float(beta[2]))

        # Draw the function on the canvas
        func.SetLineColor(ROOT.kGreen)
        canvas.cd(2)
        graph.Draw("AP")
        func.Draw("same")
                # Create residuals for fit
        canvas.cd(3)
        residuals_fit = ROOT.TGraphErrors()
        for i in range(len(T)):
            residual_fit = MoQ[i] - fit.Eval(T[i])
            residuals_fit.SetPoint(i, T[i], residual_fit)
            residuals_fit.SetPointError(i, 0, MoQError[i])
        residuals_fit.SetTitle("Residuals of ROOT Fit; T; Residuals")
        residuals_fit.SetMarkerStyle(21)
        residuals_fit.SetMarkerSize(1)
        residuals_fit.SetMarkerColor(ROOT.kRed)
        residuals_fit.Draw("AP")

        # Create residuals for func
        canvas.cd(4)
        residuals_func = ROOT.TGraphErrors()
        for i in range(len(T)):
            residual_func = MoQ[i] - func.Eval(T[i])
            residuals_func.SetPoint(i, T[i], residual_func)
            residuals_func.SetPointError(i, 0, MoQError[i])
        residuals_func.SetTitle("Residuals of Weighted Least Squares Fit; T; Residuals")
        residuals_func.SetMarkerStyle(21)
        residuals_func.SetMarkerSize(1)
        residuals_func.SetMarkerColor(ROOT.kGreen)
        residuals_func.Draw("AP")
        

    # Update and save the canvas
    canvas.Update()
    canvas.SaveAs("MassCalibrationFit.png")
    
if __name__ == "__main__":
    main()
